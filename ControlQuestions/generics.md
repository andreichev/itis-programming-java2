[Вопросы для собеседования](README.md)

# Generics
+ [Что такое Generics?](#что-такое-generics)
+ [Какова истинная цель использования обобщенных типов в Java?](#какова-истинная-цель-использования-обобщенных-типов-в-java)
+ [Как выглядит использование дженериков?](#как-выглядит-использование-дженериков)
+ [Какие есть особенности у дженериков?](#какие-есть-особенности-у-дженериков)
+ [Что означает extends?](#что-означает-extends)
+ [Что означает super?](#что-означает-super)
+ [Приведите пример стандартных классов с обобщенным типом?](#приведите-пример-стандартных-классов-с-обобщенным-типом)
+ [Несовместимость generic-типов](#несовместимость-generic-типов)
+ [Расскажите про связь дженериков с принципом подстановки Лисков](#расскажите-про-связь-дженериков-с-принципом-подстановки-лисков)
+ [Ковариантность, контравариантность и инвариантность](#ковариантность-контравариантность-и-инвариантность)
+ [Wildcards](#wildcards)
+ [Extends, super ограничения](#extends-super-ограничения)
+ [PECS (Producer Extends Consumer Super)](#pecs-producer-extends-consumer-super)
+ [<?> и Raw типы](#-и-raw-типы)
+ [Wildcard Capture](#wildcard-capture)
+ [Что такое "Переменная типа"?](#что-такое-переменная-типа)
+ [Multiple bounds (множественные ограничения)](#multiple-bounds-множественные-ограничения)
+ [Type Erasure](#type-erasure)
+ [Reifiable типы](#reifiable-типы)
+ [Пример ограничения в дженериках?](#пример-ограничения-в-дженериках)
+ [Зачем нужен бриллиантовый оператор?](#зачем-нужен-бриллиантовый-оператор)
+ [Generics в методах](#generics-в-методах)
+ [Generics в классах](#generics-в-классах)
+ [Lower bounded wildcard](#lower-bounded-wildcard)
+ [Преобразование типов](#преобразование-типов)
+ [Наследование исключений в generics](#наследование-исключений-в-generics)

## Что такое Generics?

__Дженерики__ (обобщения) — это особые средства языка Java для реализации обобщённого программирования: особого подхода к описанию данных и алгоритмов, позволяющего работать с различными типами данных без изменения их описания.

Если коротко, то Generics — это способ сказать, что класс, интерфейс, переменная или метод будут работать не с каким-то конкретным типом, а просто с каким-то. С каким именно будет определено из контекста. 

Обобщения были введены в язык Java для обеспечения более строгих проверок типов во время компиляции и для поддержки обобщенного программирования. 

[к оглавлению](#generics)

## Какова истинная цель использования обобщенных типов в Java?
Обобщенные типы в Java были изобретены, в первую очередь, для реализации
обобщенных коллекций.

[к оглавлению](#generics)

## Как выглядит использование дженериков?

Например:
```aidl
public interface List<E> extends Collection<E> {
	//...
}
```
Заранее неизвестно, объекты какого класса будут содержаться в списке, но это определится при его использовании:

```List<String> list = new ArrayList<>();```

При определении переменной даннного класса и создании объекта после имени класса в угловых скобках нужно указать, какой именно тип будет использоваться вместо универсального параметра. При этом надо учитывать, что они работают только с объектами, но не работают с примитивными типами. То есть мы можем написать `Account<Integer>`, но не можем использовать тип int или double, например, `Account<int>`. Вместо примитивных типов надо использовать классы-обертки: Integer вместо int, Double вместо double и т.д.

[к оглавлению](#generics)

## Какие есть особенности у дженериков?

Тип можно жестко задавать, например <String>, или оставить <T>

Особенностью обобщенного метода является использование универсального параметра в объявлении метода после всех модификаторов и перед типом возвращаемого значения.

```aidl
public <T> void print(T[] items)
```
Затем внутри метода все значения типа T будут представлять данный универсальный параметр.

При вызове подобного метода перед его именем в угловых скобках указывается, какой тип будет передаваться на место универсального параметра:
```
printer.<String>print(people);
printer.<Integer>print(numbers);
```

Можно подставлять несколько параметров ```<T, E> ```

Конструкторы как и методы также могут быть обобщенными. В этом случае перед конструктором также указываются в угловых скобках универсальные параметры:
```<T>Account(T id, int sum) {}```

[к оглавлению](#generics)

## Что означает extends?

Когда мы указываем универсальный параметр у обобщений, то по умолчанию он может представлять любой тип. Однако иногда необходимо, чтобы параметр соответствовал только некоторому ограниченному набору типов. 

В этом случае применяются ограничения, которые позволяют указать базовый класс, которому должен соответствовать параметр.

Для установки ограничения после универсального параметра ставится слово extends, после которого указывается базовый класс ограничения:

`class Account{ }`

`class Transaction<T extends Account>{ }`

К примеру, в данном случае для параметра `T` в `Transaction` ограничением является класс `Account`. То есть на место параметра `T` мы можем передать либо класс `Account`, либо один из его классов-наследников."

[к оглавлению](#generics)

## Что означает super?

`super B` — символ подстановки с указанием нижней границы

,где `B` — представляет собой границу"

[к оглавлению](#generics)

## Приведите пример стандартных классов с обобщенным типом?

Примером дженериков или обобщенных типов может служить библиотека с
коллекциями в Java. Например, класс `LinkedList<E>` - типичный обобщенный тип. Он
содержит параметр E, который представляет тип элементов, которые будут храниться в
коллекции. Вместо того, чтобы просто использовать `LinkedList`, ничего не говоря о
типе элемента в списке, мы можем использовать `LinkedList<String>` или
`LinkedList<Integer>`. 

Создание объектов обобщенных типов происходит посредством
замены параметризированных типов реальными типами данных. Класс типа
`LinkedList<E>` - обобщенный тип, который содержит параметр E. Создание объектов,
типа `LinkedList<String>` или `LinkedList<Integer>` называются параметризированными
типами, а `String` и `Integer` - реальные типы аргументов.

[к оглавлению](#generics)

## Несовместимость generic-типов

 __Не скомпилируется__
 ```aidl
List<String> strs = new ArrayList<String>();
List<Object> objs = strs;
 ```
`List<String>` и `List<Object>` не являются наследниками, несмотря на то что String наследует Object

В противном случае могли бы происходить ошибки вида:
 ```aidl
List<String> strs = new ArrayList<String>();
List<Object> objs = strs;
objs.add(1);
String s = strs.get(0); // <---
 ```
[к оглавлению](#generics)

## Расскажите про связь дженериков с принципом подстановки Лисков

Принцип подстановки Барбары Лисков – специфичное определение подтипа в объектно-ориентированном программировании. 
Идея Лисков о «подтипе» дает определение понятия замещения: если S является подтипом T, тогда объекты типа T в программе могут быть замещены объектами типа S без каких-либо изменений желательных свойств этой программы.

Тип - Подтип 

Number - Integer

`List<E>  - ArrayList<E>` 

`Collection<E> - List<E> `

`Iterable<E>  - Collection<E> `

Вот пример использования принципа подстановки в Java:
 ```aidl
Number n = Integer.valueOf(42);
List<Number> aList = new ArrayList<>();
Collection<Number> aCollection = aList;
Iterable<Number> iterable = aCollection;
 ```
 
 [к оглавлению](#generics)

## Ковариантность, контравариантность и инвариантность

__Ковариантность__ — это сохранение иерархии наследования исходных типов в производных типах в том же порядке. Например, если Кошка — это подтип Животные, то Множество<Кошки> — это подтип Множество<Животные>.
 Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:

Множество<Животные> = Множество<Кошки>

__Контравариантность__ — это обращение иерархии исходных типов на противоположную в производных типах. Например, если Кошка — это подтип Животные, то Множество<Животные> — это подтип Множество<Кошки>. 
Следовательно,  с учетом принципа подстановки можно выполнить такое присваивание:

Множество<Кошки> = Множество<Животные>

__Инвариантность__ — отсутствие наследования между производными типами. Если Кошка — это подтип Животные, то Множество<Кошки> не является подтипом Множество<Животные> и Множество<Животные> не является подтипом Множество<Кошки>.

Множество<Животные> != Множество<Кошки> и Множество<Кошки> != Множество<Животные>

Generic в java инвариативны. `new ArrayList<Cat>` и `new ArrayList<Animal>` не являются наследниками.

[к оглавлению](#generics)

## Wildcards
Всегда ли Generics инварианты? __Нет__. 

Wildcards позволяют разрешить такое поведение, обозначив, что в данном месте ожидается какой-то параметр типа, но не какой-то конкретный.
При этом Wildcards тоже могут быть особым образом ограничены:
- неограниченные `List<?> list = new ArrayList<Cat>();`
- ковариантные -  `List<? extends Animal> list = new ArrayList<Cat>();`
- контравариантные - `List<? super Cat> nums = new ArrayList<Animal>();`

Такие записи называется wildcard или символом подстановки, или маска. С верхней границей (extends) или с нижней границей (super). `List<? extends Number>` может содержать объекты, класс которых является Number или наследуется от Number. List<? super Number> может содержать объекты, класс которых Number или  у которых Number является наследником (супертип от Number).

[к оглавлению](#generics)

## Extends, super ограничения
Чтобы наложить ограничение на wildcard необходимо использовать конструкции типа:

- `<? extends SomeClass>` — означает, что может быть использован любой класс-наследник SomeClass
- `<? super SomeClass>` — означает, что может быть использован класс SomeClass, либо класс-родитель (или интерфейс) SomeClass

Это называется bounded wildcard.

__Если контейнер объявлен с `wildcard <? extends>`, то можно только читать значения. В список нельзя ничего добавить, кроме null. Для того чтобы добавить объект в список нам нужен другой тип wildcard — ? super__

__Нельзя прочитать элемент из контейнера с `wildcard <? super>`, кроме объекта класса Object.__

[к оглавлению](#generics)

## PECS (Producer Extends Consumer Super)
Чтобы было легче запомнить, когда какой wildcard использовать, существует принцип PECS — Producer Extends Consumer Super.

__Если мы объявили wildcard с extends, то это producer. Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает.
Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.__

Рассмотрим использование Wildcard и принципа PECS на примере метода copy в классе java.util.Collections. 

```aidl
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
 // ...
}
```
Метод осуществляет копирование элементов из исходного списка src в список dest. src — объявлен с `<? extends>` и является продюсером, а dest — объявлен с `<? super>` и является потребителем. Учитывая ковариантность и контравариантность wildcard, можно скопировать элементы из списка ints в список nums:
```
List<Number> nums = Arrays.<Number>asList(4.1F, 0.2F);
List<Integer> ints = Arrays.asList(1,2);
Collections.copy(nums, ints);
```

Если же мы по ошибке перепутаем параметры метода copy и попытаемся выполнить копирование из списка nums в список ints, то компилятор не позволит нам это сделать:
`Collections.copy(ints, nums); // Compile-time error`

[к оглавлению](#generics)

## <?> и Raw типы

Ниже приведен wildcard с неограниченным символом подстановки. Мы просто ставим `<?>`, без ключевых слов super или extends:

```aidl
static void printCollection(Collection<?> c) {
   for (Object o : c) {
       System.out.println(o);
   }
}
```
На самом деле такой «неограниченный» wildcard все-таки ограничен сверху. `Collection<?>` — это тоже символ подстановки, как и `<? extends Object>`. 

Запись вида `Collection<?>` равносильна `Collection<? extends Object>` , а значит — коллекция может содержать объекты любого класса, так как все классы в Java наследуются от Object – поэтому подстановка называется неограниченной.

Если мы опустим указание типа, например, как здесь:
`ArrayList arrayList = new ArrayList();` то, говорят, что ArrayList — это Raw тип параметризованного `ArrayList<T>`. Используя Raw типы, мы возвращаемся в эру до дженериков и сознательно отказываемся от всех фич, присущих параметризованным типам.

Если мы попытаемся вызвать параметризованный метода у Raw типа, то компилятор выдаст нам предупреждение `«Unchecked call»`. Если мы попытаемся выполнить присваивание ссылки на параметризованный тип Raw типу, то компилятор выдаст предупреждение `«Unchecked assignment»`.

[к оглавлению](#generics)

## Wildcard Capture
Попробуем теперь реализовать метод, выполняющий перестановку элементов списка в обратном порядке.

```aidl
public static void reverse(List<?> list);

// Ошибка!
public static void reverse(List<?> list) {
  List<Object> tmp = new ArrayList<Object>(list);
  for (int i = 0; i < list.size(); i++) {
    list.set(i, tmp.get(list.size()-i-1)); // compile-time error
  }
}
```
Ошибка компиляции возникла, потому что в методе reverse в качестве аргумента принимается список с неограниченным символом подстановки <?> . 

`<?> означает то же что и <? extends Object>`. 
Следовательно, согласно принципу PECS, list – это producer. А producer только продюсирует элементы. А мы в цикле for вызываем метод set(), т.е. пытаемся записать в list. И поэтому упираемся в защиту Java, что не позволяет установить какое-то значение по индексу.

Что делать? Нам поможет паттерн `Wildcard Capture`. Здесь мы создаем обобщенный метод rev. Он объявлен с переменной типа `T`. Этот метод принимает список типов T, и мы можем сделать set.
```aidl
public static void reverse(List<?> list) { 
  rev(list); 
}

private static <T> void rev(List<T> list) {
  List<T> tmp = new ArrayList<T>(list);
  for (int i = 0; i < list.size(); i++) {
    list.set(i, tmp.get(list.size()-i-1));
  }
}
```
Теперь у нас все скомпилируется. Здесь произошел __захват символа подстановки (wildcard capture)__. При вызове метода reverse(List<?> list) в качестве аргумента передается список каких-то объектов (например, строк или целых чисел). Если мы можем захватить тип этих объектов и присвоить его переменной типа X, то можем заключить, что T является X.


[к оглавлению](#generics)

## Что такое "Переменная типа"?

Когда мы записываем при объявлении класса или метода идентификатор в угловых скобках, например <T> или <E>, то создаем переменную типа. Переменная типа — это неквалифицированный идентификатор, который можно использовать в качестве типа в теле класса или метода. Переменная типа может быть ограничена сверху.
```aidl
public static <T extends Comparable<T>> T max(Collection<T> coll) {
  T candidate = coll.iterator().next();
  for (T elt : coll) {
    if (candidate.compareTo(elt) < 0) candidate = elt;
  }
  return candidate;
}
```

В этом примере выражение `T extends Comparable<T>` определяет `T` (переменную типа), ограниченную сверху типом `Comparable<T>`. В отличие от wildcard, переменные типа могут быть ограничены только сверху (только extends). Нельзя записать super. Кроме того, в этом примере T зависит от самого себя, это называется recursive bound — рекурсивная граница. 

Вот еще пример из класса Enum:
```aidl
public abstract class Enum<E extends Enum<E>>implements Comparable<E>, Serializable
```

Здесь класс `Enum` параметризован типом `E`, который является подтипом от `Enum<E>`.

[к оглавлению](#generics)

## Multiple bounds (множественные ограничения)
Multiple Bounds – множественные ограничения. Записывается через символ __&__.

```aidl
сlass A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D <T extends A & B & C> { /* ... */ }
```

Запись `O<T extends A & B & C>` образует тип пересечения __Multiple Bounds__. 

Как известно, переменная типа может быть ограничена только сверху одним или несколькими типами. В случае множественного ограничения левая граница (первое ограничение) используется в процессе затирания (__Type Erasure__).

 __Не скомпилируется__
```aidl
class D <T extends B & A & C> { /* ... */ }  
```

[к оглавлению](#generics)

## Type Erasure
__Type Erasure__ (стирание типов) - представляет собой отображение типов (возможно, включая параметризованные типы и переменные типа) на типы, которые никогда не являются параметризованными типами или переменными типами. Мы записываем затирание типа T как |T|.

Нужно оно было для совместимости байткода с предыдущими версиями Java, а заключается в том, что проверка на соответствие типов данных в generics производится исключительно __во время компиляции, а не во время выполнения__.

Стирание типа происходит во время компиляции. Компилятор Java удаляет эту информацию общего типа из источника и добавляет приведения по мере необходимости и поставляет байт-код. Поэтому сгенерированный байт-код не будет иметь никакой информации о параметрах и аргументах типа. Он будет выглядеть как старый java-код без дженериков. Невозможно определить значение T во время выполнения, поскольку эта информация удаляется до компиляции кода.

[к оглавлению](#generics)

## Reifiable типы
В Java мы говорим, что тип является reifiable, если информация о нем полностью доступна во время выполнения программы. В reifiable типы входят:
Примитивные типы (int, long, boolean)
Непараметризованные (необобщенные) типы (String, Integer)
Параметризованные типы, параметры которых представлены в виде unbounded wildcard (неограниченных символов подстановки) (`List<?>, Collection<?>`)
Raw (несформированные) типы (List, ArrayList)
Массивы, компоненты которых — Reifiable типы (int[], Number[], List<?>[], List[)

Почему информация об одних типах доступна, а о других нет? Дело в том, что из-за процесса затирания типов компилятором информация о некоторых типах может быть потеряна. Если она потерялась, то такой тип будет уже не reifiable. То есть она во время выполнения недоступна. Если доступна – соответственно, reifiable.

Решение не делать все обобщенные типы доступными во время выполнения — это одно из наиболее важных и противоречивых проектных решений в системе типов Java. Так сделали, в первую очередь, для совместимости с существующим кодом. За миграционную совместимость пришлось платить — полная доступность системы обобщенных типов во время выполнения невозможна.

Какие типы не являются reifiable:
Переменная типа T
Параметризованный тип с указанным типом параметра (`List<Number> ArrayList<String>, List<List<String>>`)
Параметризованный тип с указанной верхней или нижней границей (List<? extends Number>, Comparable<? super String>). 

Но здесь стоит оговориться: `List<? extends Object>` — не reifiable, а `List<?>` — reifiable


[к оглавлению](#generics)

## Пример ограничения в дженериках?
`mas = new T[10];`
Дело в том, что дженерики — конструкция времени компиляции, информации о настоящем типе в рантайме нет. Это называется type erasure: Java заменяет везде T на Object в скомпилированном коде (если нет дальнейших условий). При создании массива, однако, Java нуждается в информации о типе элементов, но этот тип недоступен, дженерик не имеет возможности узнать тип своего параметра T!

Поэтому и создать массив неизвестного (для дженерика) типа T в Java невозможно.

[к оглавлению](#generics)

## Зачем нужен бриллиантовый оператор?
Целью оператора алмаза является упрощение создания экземпляров родовых классов.
Например, вместо
List<Map<Integer,Set<String>>> p = new ArrayList<Map<Integer,Set<String>>>();
с алмазным оператором мы можем писать только
List<Map<Integer,Set<String>>> p = new ArrayList<>();

[к оглавлению](#generics)

## Generics в методах
`<T extends Glyph> T findNearest(Collection<T> glyphs, int x, int y) {}`

[к оглавлению](#generics)

## Generics в классах
Разрешено множественное наследование в объявление в классе (т.е. элемент должен наследовать оба интерфейса)
`class <T extends Glyph & MoveableGlyph> MoveableGlyphsContainter`
В данном примере generic-параметр должен реализовывать не только интерфейс Glyph, но и MoveableGlyph. Ограничений на количество интерфейсов, которые должен реализовывать переданный тип, нет. Но в класс можно передать только один, т.к. в Java нет множественного наследования. Типы в этом списке могут быть generic-типами, но ни один конкретный интерфейс не может появляться в списке более одного раза, даже с разными параметрами

[к оглавлению](#generics)

## Lower bounded wildcard
`<T extends Comparable<? super T>> T max(Collection<T> c) {}` - Теперь можно заполнить `List<Integer>, List<Number> или List<Object>`

[к оглавлению](#generics)

## Преобразование типов
В Generics также можно манипулировать с информацией, хранящийся в переменных.
```aidl
// Уничтожение информации о типе 
List l = new ArrayList<String>();
// Добавление информации о типе 
List<String> l = (List<String>) new ArrayList();
List<String> l1 = new ArrayList();
```

[к оглавлению](#generics)

## Наследование исключений в generics
Возможность использовать параметр generic-класса или метода в throws позволяет при описании абстрактного метода не ограничивать разработчика, использующего класс или интерфейс, конкретным типом исключения. Но использовать тип, заданный в качестве параметра, в catch-выражениях нельзя.

Кроме того, можно сгенерировать исключение, тип которого задается generic-параметром, но экземпляр должен быть создан извне. Это ограничение порождается одним из ограничений Java generic'ов - нельзя создать объект, используя оператор new, тип которого является параметром generic'а.

```
abstract class Processor <T extends Throwable>
{
    abstract void process() throws T; // ok
    void doWork()
    {
       try {
          process();
       } catch (T e) { 
	      // ошибка времени компиляции
       }
    }
    void doThrow(T except) throws T
    {
        throw except; // ok
    }
}
```
Необходимо добавить, что тип, переданный в качестве параметра, должен обязательно быть наследником Throwable.

[к оглавлению](#generics)

## Дополнительные материалы

+ [Использование generic wildcards для повышения удобства Java API](https://habr.com/ru/post/207360/)
+ [Пришел, увидел, обобщил: погружаемся в Java Generics](https://habr.com/ru/company/sberbank/blog/416413/)
+ [Дженерики (Java, обучающая статья)](http://www.quizful.net/post/java-generics-tutorial)
+ [Теория дженериков в Java или как на практике ставить скобки](https://javarush.ru/groups/posts/2004-teorija-dzhenerikov-v-java-ili-gde-na-praktike-stavitjh-skobki)

[к оглавлению](#generics)

[Вопросы для собеседования](README.md)
